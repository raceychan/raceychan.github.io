"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[8812],{15216:e=>{e.exports=JSON.parse('{"permalink":"/ru/blog/Most-Design-Patterns-Are-Just-Dependency-Injection-In-Disguise","source":"@site/blog/2025-07-12T10_48-most-design-patterns-are-just-dependency-injection-in-disguise/content.md","title":"Most Design Patterns Are Just Dependency Injection in Disguise","description":"Design patterns are a helpful way to talk about structure \u2014 reusable blueprints for solving common problems in code. They give us a shared vocabulary, and when used well, they make systems more flexible and understandable.","date":"2025-07-12T00:00:00.000Z","tags":[{"inline":false,"label":"python","permalink":"/ru/blog/tags/python","description":"general dicussion about programming in python"},{"inline":true,"label":"design patterns","permalink":"/ru/blog/tags/design-patterns"},{"inline":false,"label":"OOP","permalink":"/ru/blog/tags/oop","description":"Object-oriented programming principles and practices"}],"readingTime":4.805,"hasTruncateMarker":true,"authors":[{"name":"raceychan","title":"author of lihil, a developer.","url":"https://github.com/raceychan","page":{"permalink":"/ru/blog/authors/raceychan"},"socials":{"x":"https://x.com/raceychan","github":"https://github.com/raceychan"},"imageURL":"https://github.com/raceychan.png","key":"raceychan"}],"frontMatter":{"slug":"Most-Design-Patterns-Are-Just-Dependency-Injection-In-Disguise","title":"Most Design Patterns Are Just Dependency Injection in Disguise","authors":["raceychan"],"tags":["python","design patterns","oop"],"toc_min_heading_level":2,"toc_max_heading_level":5},"unlisted":false,"nextItem":{"title":"Design Patterns You Should Unlearn in Python-Part2","permalink":"/ru/blog/design-patterns-you-should-unlearn-in-python-part2"}}')},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},45506:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=n(15216),a=n(74848),i=n(28453);const o={slug:"Most-Design-Patterns-Are-Just-Dependency-Injection-In-Disguise",title:"Most Design Patterns Are Just Dependency Injection in Disguise",authors:["raceychan"],tags:["python","design patterns","oop"],toc_min_heading_level:2,toc_max_heading_level:5},r="Most Design Patterns Are Just Dependency Injection in Disguise",l={authorsImageUrls:[void 0]},c=[{value:"The Strategy Pattern: The Gateway Drug",id:"the-strategy-pattern-the-gateway-drug",level:2},{value:"The State Pattern: Strategy with Memory",id:"the-state-pattern-strategy-with-memory",level:2},{value:"The Adapter Pattern: Strategy with an Accent",id:"the-adapter-pattern-strategy-with-an-accent",level:2},{value:"Other Patterns That Also Fall In Line",id:"other-patterns-that-also-fall-in-line",level:2},{value:"So... What&#39;s Actually Happening?",id:"so-whats-actually-happening",level:2},{value:"Dependency Injection (DI)",id:"dependency-injection-di",level:3},{value:"Subclassing and Liskov Substitution",id:"subclassing-and-liskov-substitution",level:3},{value:"The Open/Closed Principle (OCP)",id:"the-openclosed-principle-ocp",level:3},{value:"You Don\u2019t Need to Memorize Patterns \u2014 Just Learn These",id:"you-dont-need-to-memorize-patterns--just-learn-these",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Design patterns are a helpful way to talk about structure \u2014 reusable blueprints for solving common problems in code. They give us a shared vocabulary, and when used well, they make systems more flexible and understandable."}),"\n",(0,a.jsx)(t.p,{children:"But once you\u2019ve worked with a few of them, you start to notice something: a lot of patterns look suspiciously similar in actual implementation. You\u2019re injecting different behaviors, delegating to different components, maybe wrapping an object to change what it does \u2014 but structurally, it\u2019s often the same playbook with different labels."}),"\n",(0,a.jsxs)(t.p,{children:["This post looks at a few well-known patterns \u2014 Strategy, State, Adapter, Proxy, Command \u2014 and makes the case that most of them reduce to the same fundamental technique: ",(0,a.jsx)(t.strong,{children:"Dependency Injection"}),". And once you add in two key design principles \u2014 ",(0,a.jsx)(t.strong,{children:"Open/Closed"})," and ",(0,a.jsx)(t.strong,{children:"Liskov Substitution"})," \u2014 you\u2019ll find you can design pattern-like solutions without memorizing any formal templates."]}),"\n",(0,a.jsx)(t.p,{children:"Let\u2019s start with the one pattern you probably used even before you knew what it was:"}),"\n",(0,a.jsx)(t.h2,{id:"the-strategy-pattern-the-gateway-drug",children:"The Strategy Pattern: The Gateway Drug"}),"\n",(0,a.jsx)(t.p,{children:"The Strategy pattern is the classic answer to \u201cI need to do something in multiple ways, and I want to swap that behavior at runtime.\u201d You define an interface, then inject different implementations depending on what you\u2019re trying to do."}),"\n",(0,a.jsx)(t.p,{children:"In plain English: it's just a fancy way of passing a function (or object) into another object to do something configurable."}),"\n",(0,a.jsx)(t.p,{children:"Here\u2019s a not-so-contrived example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"from typing import Protocol\n\nclass DiscountStrategy(Protocol):\n    def apply(self, price: float) -> float: ...\n\nclass TenPercentDiscount:\n    def apply(self, price: float) -> float:\n        return price * 0.9\n\nclass NoDiscount:\n    def apply(self, price: float) -> float:\n        return price\n\nclass Checkout:\n    def __init__(self, discount: DiscountStrategy):\n        self.discount = discount\n\n    def total(self, price: float) -> float:\n        return self.discount.apply(price)\n"})}),"\n",(0,a.jsx)(t.p,{children:"Usage:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"checkout = Checkout(TenPercentDiscount())\nprint(checkout.total(100))\n"})}),"\n",(0,a.jsx)(t.p,{children:"And just like that, you\u2019ve implemented the Strategy pattern. Did we need to call it that? Not really. In Python, it just looks like... dependency injection."}),"\n",(0,a.jsx)(t.h2,{id:"the-state-pattern-strategy-with-memory",children:"The State Pattern: Strategy with Memory"}),"\n",(0,a.jsx)(t.p,{children:"The State pattern is basically the Strategy pattern with a twist: the injected object also holds some internal state and may modify itself or the context based on that."}),"\n",(0,a.jsxs)(t.p,{children:["You know how in a game you might have ",(0,a.jsx)(t.code,{children:"IdleState"}),", ",(0,a.jsx)(t.code,{children:"RunningState"}),", ",(0,a.jsx)(t.code,{children:"DeadState"}),', and each one handles user input differently? That\u2019s State pattern territory. But again, at its core, you\'re injecting behavior \u2014 the current "state object" \u2014 and swapping it out when needed.']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'class State(Protocol):\n    def handle(self) -> None: ...\n\nclass Idle:\n    def handle(self) -> None:\n        print("Doing nothing")\n\nclass Running:\n    def handle(self) -> None:\n        print("Running!")\n\nclass Character:\n    def __init__(self, state: State):\n        self.state = state\n\n    def update(self):\n        self.state.handle()\n'})}),"\n",(0,a.jsx)(t.p,{children:"It's Strategy, but with a bit more drama."}),"\n",(0,a.jsx)(t.h2,{id:"the-adapter-pattern-strategy-with-an-accent",children:"The Adapter Pattern: Strategy with an Accent"}),"\n",(0,a.jsx)(t.p,{children:"The Adapter pattern is about taking an object with the wrong shape and giving it the right one, usually by wrapping it."}),"\n",(0,a.jsxs)(t.p,{children:["Example: You have a library that expects a ",(0,a.jsx)(t.code,{children:"Logger"})," with a ",(0,a.jsx)(t.code,{children:"log()"})," method, but you\u2019re stuck with one that has a ",(0,a.jsx)(t.code,{children:"write()"})," method instead."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'class LegacyLogger:\n    def write(self, msg: str) -> None:\n        print(f"[legacy] {msg}")\n\nclass LoggerAdapter:\n    def __init__(self, adaptee: LegacyLogger):\n        self.adaptee = adaptee\n\n    def log(self, msg: str) -> None:\n        self.adaptee.write(msg)\n'})}),"\n",(0,a.jsx)(t.p,{children:"Did we just inject behavior via composition and delegation? Yes. Are we still in Strategy territory? Also yes."}),"\n",(0,a.jsx)(t.h2,{id:"other-patterns-that-also-fall-in-line",children:"Other Patterns That Also Fall In Line"}),"\n",(0,a.jsxs)(t.p,{children:["You don\u2019t need to look far to see that ",(0,a.jsx)(t.strong,{children:"Proxy"}),", ",(0,a.jsx)(t.strong,{children:"Command"}),", ",(0,a.jsx)(t.strong,{children:"Decorator"}),", and ",(0,a.jsx)(t.strong,{children:"Visitor"})," can all be reduced to:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Inject something into something else"}),"\n",(0,a.jsx)(t.li,{children:"Call a method on it"}),"\n",(0,a.jsx)(t.li,{children:"Maybe wrap it or delegate behavior"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Patterns differ more in ",(0,a.jsx)(t.em,{children:"intent"})," than ",(0,a.jsx)(t.em,{children:"structure"}),". Which brings us to the point of this whole exercise."]}),"\n",(0,a.jsx)(t.h2,{id:"so-whats-actually-happening",children:"So... What's Actually Happening?"}),"\n",(0,a.jsxs)(t.p,{children:["What\u2019s underneath all of these patterns is just ",(0,a.jsx)(t.strong,{children:"Dependency Injection"})," plus ",(0,a.jsx)(t.strong,{children:"subclassing"})," (or duck typing), guided by two classic principles:"]}),"\n",(0,a.jsx)(t.h3,{id:"dependency-injection-di",children:"Dependency Injection (DI)"}),"\n",(0,a.jsx)(t.p,{children:"DI is the idea that instead of hardcoding dependencies inside a class, you pass them in. This makes testing, configuration, and extension way easier."}),"\n",(0,a.jsx)(t.p,{children:"In Python, DI is dead simple. Just pass stuff to the constructor (or function). No frameworks required."}),"\n",(0,a.jsx)(t.h3,{id:"subclassing-and-liskov-substitution",children:"Subclassing and Liskov Substitution"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"Liskov Substitution Principle"})," (LSP) says: if you write code to an interface, any implementation should be swappable without surprises. Strategy, State, and the rest rely on this idea to keep behavior modular and interchangeable."]}),"\n",(0,a.jsx)(t.h3,{id:"the-openclosed-principle-ocp",children:"The Open/Closed Principle (OCP)"}),"\n",(0,a.jsx)(t.p,{children:"OCP says software entities should be open for extension, but closed for modification. In practice, this means: don\u2019t rewrite a class to change its behavior, inject a new one instead."}),"\n",(0,a.jsx)(t.p,{children:"When you use DI + LSP + OCP, you naturally end up with code that looks like a design pattern without having to name it."}),"\n",(0,a.jsx)(t.h2,{id:"you-dont-need-to-memorize-patterns--just-learn-these",children:"You Don\u2019t Need to Memorize Patterns \u2014 Just Learn These"}),"\n",(0,a.jsx)(t.p,{children:"If you understand:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"How to inject behavior (via functions, objects, or composition)"}),"\n",(0,a.jsx)(t.li,{children:"How to write to abstractions, not concretions"}),"\n",(0,a.jsx)(t.li,{children:"How to keep components swappable and extendable"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"...you\u2019re already halfway to implementing 80% of the Gang of Four catalog."}),"\n",(0,a.jsx)(t.p,{children:"Patterns are useful as vocabulary when communicating with other developers. But in Python, especially, we often don\u2019t need to formally implement them \u2014 we just need to understand the problem they solve, and pick the cleanest way to solve it."}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(t.p,{children:["Design patterns aren\u2019t bad \u2014 they\u2019re just overused and over-taught as if they\u2019re sacred scripture. But most of them are really just different flavors of ",(0,a.jsx)(t.strong,{children:"Dependency Injection"}),", powered by ",(0,a.jsx)(t.strong,{children:"LSP"})," and ",(0,a.jsx)(t.strong,{children:"OCP"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"So instead of memorizing 23 pattern templates, you\u2019ll get much farther by learning:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"How to inject behavior"}),"\n",(0,a.jsx)(t.li,{children:"How to write extensible abstractions"}),"\n",(0,a.jsx)(t.li,{children:"How to avoid rewriting code when you can just plug in new stuff"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The patterns will follow. And if they don\u2019t, maybe you didn\u2019t need them in the first place."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
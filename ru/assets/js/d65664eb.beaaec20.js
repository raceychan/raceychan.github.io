"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[375],{747:e=>{e.exports=JSON.parse('{"permalink":"/ru/blog/encapsulation-isnt-javas-fault-and-python-needs-it-too","source":"@site/blog/2025-08-03T14_29-encapsulation-beyond-syntax-do-access-modifiers-still-matter/content.md","title":"Encapsulation Isn\u2019t Java\u2019s Fault (And Python Needs It Too)","description":"gears","date":"2025-08-03T00:00:00.000Z","tags":[{"inline":false,"label":"python","permalink":"/ru/blog/tags/python","description":"general dicussion about programming in python"},{"inline":false,"label":"OOP","permalink":"/ru/blog/tags/oop","description":"Object-oriented programming principles and practices"}],"readingTime":11.175,"hasTruncateMarker":true,"authors":[{"name":"raceychan","title":"author of lihil, a developer.","url":"https://github.com/raceychan","page":{"permalink":"/ru/blog/authors/raceychan"},"imageURL":"https://github.com/raceychan.png","key":"raceychan"}],"frontMatter":{"slug":"encapsulation-isnt-javas-fault-and-python-needs-it-too","title":"Encapsulation Isn\u2019t Java\u2019s Fault (And Python Needs It Too)","authors":["raceychan"],"tags":["python","oop"]},"unlisted":false,"nextItem":{"title":"Design Patterns You Should Unlearn in Python-Part2","permalink":"/ru/blog/design-patterns-you-should-unlearn-in-python-part2"}}')},10336:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/protected_attr-70c2b72b17e6d2780038a5c1115b505b.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(96540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},84379:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var t=s(747),a=s(74848),i=s(28453);const o={slug:"encapsulation-isnt-javas-fault-and-python-needs-it-too",title:"Encapsulation Isn\u2019t Java\u2019s Fault (And Python Needs It Too)",authors:["raceychan"],tags:["python","oop"]},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"<strong>Access Modifiers: What They Are, and What They Look Like</strong>",id:"access-modifiers-what-they-are-and-what-they-look-like",level:2},{value:"<strong>Why Do We Need Encapsulation?</strong>",id:"why-do-we-need-encapsulation",level:3},{value:"<strong>What Happens Without It?</strong>",id:"what-happens-without-it",level:3},{value:"<strong>Why We Didn\u2019t Need It as Much Before</strong>",id:"why-we-didnt-need-it-as-much-before",level:3},{value:"when to use access modifier and when not to",id:"when-to-use-access-modifier-and-when-not-to",level:2},{value:"Anti-patterns",id:"anti-patterns",level:3},{value:"<strong>Encapsulation Beyond Classes</strong>",id:"encapsulation-beyond-classes",level:3},{value:"Python (Module-Level)",id:"python-module-level",level:3},{value:"TypeScript (File/Module-Level)",id:"typescript-filemodule-level",level:3},{value:"Encapsulation beyond code",id:"encapsulation-beyond-code",level:2},{value:"<strong>Wrapping Up</strong>",id:"wrapping-up",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://unsplash.com/photos/JBZvYieOmCQ/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8N3x8bWVjaGFuaWNzfGVufDB8fHx8MTc1NDI0NjQ1OXww&force=true&w=1920",alt:"gears"})}),"\n",(0,a.jsx)(n.p,{children:"Encapsulation in Python is one of those topics that often gets brushed off,  either as unnecessary boilerplate or as baggage from statically typed languages like Java and C++. In many Python teams, it\u2019s treated as optional, or worse, irrelevant."}),"\n",(0,a.jsx)(n.p,{children:"But this casual attitude has a cost."}),"\n",(0,a.jsx)(n.p,{children:"As Python takes on a bigger role in enterprise software, especially with the rise of AI, more teams are building larger, more complex systems together. Without proper encapsulation, internal changes in one part of the codebase can leak out and break things for everyone else. It becomes harder to reason about code boundaries, harder to collaborate, and harder to move fast without stepping on each other\u2019s toes."}),"\n",(0,a.jsxs)(n.p,{children:["In this post, we\u2019ll talk about ",(0,a.jsx)(n.strong,{children:"why encapsulation still matters in Python"}),", why it\u2019s becoming increasingly important, and how to approach it in a way that actually fits the language and its philosophy."]}),"\n",(0,a.jsxs)(n.p,{children:["And just in case you\u2019re wondering: ",(0,a.jsx)(n.strong,{children:'no, this won\u2019t be one of those "here\u2019s how to mimic Java\u2019s access modifiers in Python" posts.'})," We're going deeper than that."]}),"\n",(0,a.jsx)(n.h2,{id:"access-modifiers-what-they-are-and-what-they-look-like",children:(0,a.jsx)(n.strong,{children:"Access Modifiers: What They Are, and What They Look Like"})}),"\n",(0,a.jsxs)(n.p,{children:["When people think of encapsulation, they often jump straight to ",(0,a.jsx)(n.strong,{children:"access modifiers"}),", and it\u2019s easy to see why. In many languages, access modifiers are the main way to draw boundaries between internal and external code."]}),"\n",(0,a.jsx)(n.p,{children:"In Java, for example, you have explicit keywords:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"\npublic class UserService {\n    protected UserRepository repository;\n\n    public void register(User user) {\n        // ...\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, ",(0,a.jsx)(n.code,{children:"protected"})," means no one outside the class(and its subclasses) can touch ",(0,a.jsx)(n.code,{children:"repository"}),", and ",(0,a.jsx)(n.code,{children:"public"})," means anyone can call ",(0,a.jsx)(n.code,{children:"register"}),"."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"protected"})," is less strict in java, other classes ",(0,a.jsx)(n.strong,{children:"in the same package"})," can access protected member as well."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Python takes a different approach, instead of forcing strict access modifiers at interpreter level, it relies on naming conventions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class UserService:\n    def __init__(self, repo: UserRepository):\n        self._repository = repo\n\n    def register(self, user: UserInfo):\n        ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the leading underscore in ",(0,a.jsx)(n.code,{children:"_repository"})," is Python\u2019s way of saying \u201chey, this is internal,  don\u2019t mess with it.\u201d But it\u2019s just a convention. You ",(0,a.jsx)(n.em,{children:"can"})," still access it from the outside. If your type checker is configured correctly, it might warn you, but nothing at the interpreter level will stop you. No exceptions will be raised."]}),"\n",(0,a.jsx)(n.h3,{id:"why-do-we-need-encapsulation",children:(0,a.jsx)(n.strong,{children:"Why Do We Need Encapsulation?"})}),"\n",(0,a.jsxs)(n.p,{children:["The primary reason is simple: ",(0,a.jsx)(n.strong,{children:"to draw a line between what's internal and what's public"}),". That line lets other developers,  or even future-you,  know what\u2019s safe to rely on and what isn\u2019t. When a method or attribute is marked internal (e.g. with a leading underscore), you're saying: ",(0,a.jsx)(n.em,{children:"this is part of the implementation, not the interface."})]}),"\n",(0,a.jsxs)(n.p,{children:["Why does that matter? Because once other parts of the codebase,  or worse, external systems,  start depending on your internal details, ",(0,a.jsx)(n.strong,{children:"you lose the freedom to change them"}),". If you need to refactor, simplify, or remove something, you risk breaking unknown callers."]}),"\n",(0,a.jsxs)(n.p,{children:["This is not a new problem. Software engineering has wrestled with this for decades, and the solution has been expressed through principles like the ",(0,a.jsx)(n.strong,{children:"Open/Closed Principle (OCP)"}),":"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Software entities should be open for extension but closed for modification."})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Encapsulation supports this by letting you change how things work internally, ",(0,a.jsx)(n.strong,{children:"without changing the parts others depend on"}),". When we design a class with a clear public interface and hidden internals, we make it easier to evolve the code over time without introducing regressions."]}),"\n",(0,a.jsxs)(n.p,{children:["When we ",(0,a.jsx)(n.em,{children:"do"})," need to expose something, we can still preserve encapsulation using tools like ",(0,a.jsx)(n.code,{children:"@property"}),". This lets us provide a stable public interface, while keeping the flexibility to change how things work behind the scenes,  coercing types, adding guards, lazy-loading data, etc."]}),"\n",(0,a.jsxs)(n.p,{children:["In general, when a class represents business logic, it\u2019s often a good idea to ",(0,a.jsx)(n.strong,{children:"default to making members protected"})," and ",(0,a.jsx)(n.strong,{children:"only expose public methods that represent meaningful, validated operations"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Take this example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'@dataclass\nclass UserInfo:\n    email: str\n    name: str\n    role: str = "user"\n\nclass UserService:\n    def __init__(self, user_repo: UserRepository):\n        self._repo = user_repo\n\n    def register(self, user: UserInfo):\n        self._validate_email(user.email)\n        self._validate_role(user.role)\n        self._repo.add_user(user)\n\n    def _validate_email(self, email: str): ...\n    def _validate_role(self, role: str): ...\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Here, we don't want other services to call ",(0,a.jsx)(n.code,{children:"_validate_email"})," or ",(0,a.jsx)(n.code,{children:"_repo.add_user()"})," directly. Those are internal details that can change. What we ",(0,a.jsx)(n.em,{children:"do"})," want them to use is the stable ",(0,a.jsx)(n.code,{children:"register()"})," interface."]}),"\n",(0,a.jsx)(n.h3,{id:"what-happens-without-it",children:(0,a.jsx)(n.strong,{children:"What Happens Without It?"})}),"\n",(0,a.jsx)(n.p,{children:"Now let\u2019s imagine we didn\u2019t bother with any of this,  we just exposed everything."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Somewhere else in the codebase\nservice = UserService()\nuser = UserProfile(email="a@example.com", name="Alice")\nservice.repository.add_user(user)  # Uh-oh\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Other parts of the system might start calling ",(0,a.jsx)(n.code,{children:"user_repo.add_user()"})," directly, bypassing all the validation logic in ",(0,a.jsx)(n.code,{children:"UserService.register()"}),". That could lead to subtle, inconsistent behavior, or worse,  bad data getting into your system."]}),"\n",(0,a.jsxs)(n.p,{children:["Or maybe someone starts reusing ",(0,a.jsx)(n.code,{children:"_validate_email()"})," from somewhere else. But since it was never meant to be used externally, one day we remove it during a refactor,  and now their code breaks. Whose fault is it? Technically not yours, but it sure won't feel that way when you\u2019re on the hook for fixing it."]}),"\n",(0,a.jsxs)(n.p,{children:["When everything is public, ",(0,a.jsx)(n.strong,{children:"every change becomes dangerous"}),". Before touching anything, you have to check who\u2019s using it. Modify a method? Now you\u2019re spelunking through half the codebase, updating every dependent. It\u2019s a maintenance nightmare."]}),"\n",(0,a.jsxs)(n.p,{children:["Encapsulation reduces that cognitive load. It tells you what you can change freely and what you need to be careful with. It gives your code ",(0,a.jsx)(n.strong,{children:"safe zones"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"why-we-didnt-need-it-as-much-before",children:(0,a.jsx)(n.strong,{children:"Why We Didn\u2019t Need It as Much Before"})}),"\n",(0,a.jsx)(n.p,{children:"So why hasn\u2019t this been a bigger issue in Python until now?"}),"\n",(0,a.jsx)(n.p,{children:"For a long time, many people use Python for small-scale projects, things like automation scripts, scientific prototypes, academic experiments, or exploratory data work. In those contexts, it didn\u2019t really matter if internals were exposed, because the same person was writing, reading, and maintaining the entire codebase."}),"\n",(0,a.jsx)(n.p,{children:"However, over the past decade, Python has steadily grown into a first-class language for building AI, data heavy systems. The rise of web frameworks like Django and FastAPI, the explosion of machine learning libraries like TensorFlow and PyTorch, and the growth of async tooling and cloud-native workflows have all made Python a serious player in enterprise software development."}),"\n",(0,a.jsx)(n.p,{children:"Also, before Python 3.6, we simply didn\u2019t have the tools to enforce encapsulation effectively. Without type hints and the ecosystem around them, it was hard to even notice violations of protected members, let alone prevent them. Now, with tools like pyright, mypy, and IDEs like VSCode, we can catch those violations early."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"procted_attr",src:s(10336).A+"",width:"1907",height:"262"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Example vscode config from lihil"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-toml",children:'[tool.pyright]\nexclude = ["tests"]\ninclude = ["lihil/*.py"]\npython_version = "3.10"\ntypeCheckingMode = "strict"\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"when-to-use-access-modifier-and-when-not-to",children:"when to use access modifier and when not to"}),"\n",(0,a.jsx)(n.p,{children:"Not all classes are created equal. Their purpose affects how much encapsulation you really need,  and what kind."}),"\n",(0,a.jsxs)(n.p,{children:["Let\u2019s take two common categories: ",(0,a.jsx)(n.strong,{children:"data classes"})," and ",(0,a.jsx)(n.strong,{children:"service classes"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Data classes are meant to carry state. But sometimes we start stuffing behavior and dependencies into them,  and that\u2019s when things get messy. Consider this example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"@dataclass\nclass UserManager:\n    users: list[UserInfo]\n    engine: AsyncEngine  # external dependency\n\n    def add_user(self, user_info: UserInfo):\n        ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["At first glance, this looks fine. But ",(0,a.jsx)(n.code,{children:"engine"})," is not really just data,  it\u2019s a dependency. It probably shouldn't be public, but because this is a dataclass, ",(0,a.jsx)(n.em,{children:"everything is public by default"}),". You don\u2019t get any real control over what\u2019s exposed, which can lead to tight coupling and leaky abstractions."]}),"\n",(0,a.jsx)(n.p,{children:"Now let\u2019s flip the problem: a service class with too many internal configuration values."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class FileDownloader:\n    def __init__(self, session: ClientSession):\n        self._session = session\n        self._max_concurrent = 3\n        self._max_file_size = 100 * 1024 * 1024\n        self._timeout = 10\n        self._retries = 2\n        self._allow_redirect = True\n        # and the list goes on...\n\n    def download(self, url: str):\n        ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Each of these config values might need to be accessed from outside the class, but none of them are really ",(0,a.jsx)(n.em,{children:"business logic"}),". So now you're stuck adding five ",(0,a.jsx)(n.code,{children:"@property"})," methods just to make them selectively public. That's tedious and clutters the class with boilerplate."]}),"\n",(0,a.jsx)(n.p,{children:"A better approach? Extract the config into a separate dataclass:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"@dataclass\nclass DownloadConfig:\n    max_concurrent: int = 3\n    max_file_size: int = 100 * 1024 * 1024\n    timeout: int = 10\n    retries: int = 2\n    allow_redirect: bool = True\n\nclass FileDownloader:\n    def __init__(self, session: ClientSession, config: DownloadConfig):\n        self._session = session\n        self._config = config\n\n    @property\n    def config(self) -> DownloadConfig:\n        return self._config\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now the ",(0,a.jsx)(n.code,{children:"FileDownloader"})," focuses on behavior, and the data lives in a plain, easy-to-inspect structure. No clutter. No second-guessing access modifiers."]}),"\n",(0,a.jsx)(n.p,{children:"If you mix state and behavior carelessly, encapsulation decisions get exhausting,  you\u2019ll find yourself manually evaluating every attribute and method. But when the design is clear, the modifiers fall into place naturally."}),"\n",(0,a.jsx)(n.h3,{id:"anti-patterns",children:"Anti-patterns"}),"\n",(0,a.jsx)(n.p,{children:"The worst-case scenario is blindly adding getters and setters for everything,  especially when they don\u2019t do anything useful. If you\u2019re not doing validation, type coercion, or state transformation, a setter is just noise."}),"\n",(0,a.jsx)(n.p,{children:"Let\u2019s look at an example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class Project:\n    def __init__(self, status: str):\n        self._status = status\n\n\t@property\n    def status(self) -> str: return self._status\n\n\t@status.setter\n    def status(self, status: str): self._status = status\n"})}),"\n",(0,a.jsx)(n.p,{children:"What value does this add? The methods don\u2019t protect anything. They don\u2019t clarify intent. They just waste space and give a false sense of encapsulation."}),"\n",(0,a.jsx)(n.p,{children:"Now compare that to this alternative:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class Project:\n    def __init__(self, status: str):\n        self._status = status\n\n    def mark_as_completed(self, reason: str | None = None):\n        """Mark the project as completed, with an optional reason for tracking."""\n        if self._status == "comleted":\n\t        return\n\t\tif self._status not in ("started", "running"):\n\t\t    raise InvalidStatusError(self._status)\n\n        self._status = "completed"\n        if reason:\n            self._log_reason(reason)\n'})}),"\n",(0,a.jsx)(n.p,{children:"This version is doing real work. You can pass multiple arguments. The method names express intent. The docstrings help the reader understand context. It\u2019s much more maintainable and far less dogmatic."}),"\n",(0,a.jsxs)(n.p,{children:["And while we\u2019re at it: don\u2019t abuse ",(0,a.jsx)(n.strong,{children:"inheritance"})," either. You can spend all day trying to protect internals from subclasses,  or you can just stop subclassing altogether."]}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes the simpler answer is to design your class as effectively ",(0,a.jsx)(n.strong,{children:"final"}),", and let other classes ",(0,a.jsx)(n.strong,{children:"depend on it via composition"}),". You avoid the pitfalls of fragile base classes, and you make encapsulation easier to reason about."]}),"\n",(0,a.jsxs)(n.p,{children:["Yes, ",(0,a.jsx)(n.em,{children:"composition over inheritance"}),". Not always. But definitely more often than some legacy tutorials would have you believe."]}),"\n",(0,a.jsx)(n.h3,{id:"encapsulation-beyond-classes",children:(0,a.jsx)(n.strong,{children:"Encapsulation Beyond Classes"})}),"\n",(0,a.jsxs)(n.p,{children:["Encapsulation isn\u2019t just about hiding attributes inside a class. The same principle applies at higher levels,  ",(0,a.jsx)(n.strong,{children:"modules"}),", ",(0,a.jsx)(n.strong,{children:"packages"}),", and even ",(0,a.jsx)(n.strong,{children:"entire applications"}),". It's all about controlling what gets exposed and what stays internal."]}),"\n",(0,a.jsx)(n.p,{children:"Let\u2019s look at a few examples."}),"\n",(0,a.jsx)(n.h3,{id:"python-module-level",children:"Python (Module-Level)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# token_service/__init__.py \n\nfrom .service import TokenService  \n__all__ = ["TokenService"]  # Everything else stays internal\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can also use leading underscores for private helpers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# token_service/utils.py \ndef _sign_payload(...): ...\n"})}),"\n",(0,a.jsx)(n.p,{children:'This tells both humans and tools: "this isn\u2019t part of the public interface."'}),"\n",(0,a.jsx)(n.h3,{id:"typescript-filemodule-level",children:"TypeScript (File/Module-Level)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"// token_service.ts\n\nexport class TokenService {}       // public\nclass InternalCache {}             // not exported = internal to the module\n"})}),"\n",(0,a.jsx)(n.p,{children:"If it\u2019s not exported, it\u2019s not part of the API. That\u2019s module-level encapsulation."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"And you can scale this even further."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["At the ",(0,a.jsx)(n.strong,{children:"package level"}),", you decide which modules to expose in ",(0,a.jsx)(n.code,{children:"__init__.py"})," or in your ",(0,a.jsx)(n.code,{children:"pyproject.toml"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["At the ",(0,a.jsx)(n.strong,{children:"application level"}),", you expose only selected routes in your web API or specific commands in your CLI. Everything else stays behind the scenes."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"encapsulation-beyond-code",children:"Encapsulation beyond code"}),"\n",(0,a.jsxs)(n.p,{children:["Encapsulation doesn\u2019t stop at classes, functions, or modules, it applies at the ",(0,a.jsx)(n.strong,{children:"architectural level"}),", too."]}),"\n",(0,a.jsxs)(n.p,{children:["In a microservice-based system, each service is an isolated unit with its own data, logic, and internal state. You don\u2019t (and shouldn\u2019t) reach across service boundaries to query another service\u2019s database or call its internal methods. Instead, communication happens through ",(0,a.jsx)(n.strong,{children:"well-defined interfaces"}),", usually REST, gRPC, or message queues."]}),"\n",(0,a.jsx)(n.p,{children:"This is encapsulation at the system level:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A service only exposes the API endpoints it wants others to use."}),"\n",(0,a.jsx)(n.li,{children:"Internal components like DAOs, caches, feature flags, or job queues are entirely hidden."}),"\n",(0,a.jsx)(n.li,{children:"Breaking changes can be avoided because external consumers never depend on internal details."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["A good example would be an ",(0,a.jsx)(n.strong,{children:"API Gateway"}),". To the caller, it stays transparent. But behind the scenes, the gateway might route the request to multiple services, apply authentication, logging, retries, or circuit-breaking logic. None of that is exposed. The caller doesn't know, and doesn't need to."]}),"\n",(0,a.jsxs)(n.p,{children:["It\u2019s the same idea as ",(0,a.jsx)(n.code,{children:"private"})," or ",(0,a.jsx)(n.code,{children:"protected"}),", just scaled out over a network."]}),"\n",(0,a.jsx)(n.p,{children:"Whether you\u2019re defining a Python method, a Go module, or a service boundary in your infrastructure, the principle is the same:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Hide internal details. Expose a clean, intentional interface. Decouple everything else."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"wrapping-up",children:(0,a.jsx)(n.strong,{children:"Wrapping Up"})}),"\n",(0,a.jsxs)(n.p,{children:["Encapsulation isn\u2019t about following rules,  it\u2019s about creating ",(0,a.jsx)(n.strong,{children:"boundaries that protect your code"}),". Whether you\u2019re building a Python library, designing a class, organizing a module, or architecting an entire system, the goal is the same: ",(0,a.jsx)(n.strong,{children:"make the interface clear, keep the internals private, and give yourself room to evolve"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["In Python, we don\u2019t have enforced access modifiers,  and that\u2019s fine. We have conventions, type checkers, and design discipline. What matters is that you ",(0,a.jsx)(n.em,{children:"use them deliberately"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Don\u2019t add encapsulation for its it-tooown sake. But don\u2019t dismiss it just because you\u2019re writing Python. If anything, Python\u2019s flexibility makes it ",(0,a.jsx)(n.em,{children:"more"})," important to clearly mark your boundaries."]}),"\n",(0,a.jsx)(n.p,{children:"Start by separating your data classes from your service classes. Use underscores to guide intention. Avoid meaningless setters. Prefer real methods with real names. And think in terms of public interfaces,  whether you're building a class or an entire API."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
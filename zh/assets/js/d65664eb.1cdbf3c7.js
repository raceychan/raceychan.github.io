"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[375],{747:e=>{e.exports=JSON.parse('{"permalink":"/zh/blog/encapsulation-beyond-syntax-do-access-modifiers-still-matter","source":"@site/blog/2025-08-03T14_29-encapsulation-beyond-syntax-do-access-modifiers-still-matter/content.md","title":"Encapsulation Beyond Syntax: Do Access Modifiers Still Matter?","description":"gears","date":"2025-08-03T00:00:00.000Z","tags":[{"inline":false,"label":"python","permalink":"/zh/blog/tags/python","description":"general dicussion about programming in python"},{"inline":false,"label":"OOP","permalink":"/zh/blog/tags/oop","description":"Object-oriented programming principles and practices"}],"readingTime":12.15,"hasTruncateMarker":true,"authors":[{"name":"raceychan","title":"author of lihil, a developer.","url":"https://github.com/raceychan","page":{"permalink":"/zh/blog/authors/raceychan"},"imageURL":"https://github.com/raceychan.png","key":"raceychan"}],"frontMatter":{"slug":"encapsulation-beyond-syntax-do-access-modifiers-still-matter","title":"Encapsulation Beyond Syntax: Do Access Modifiers Still Matter?","authors":["raceychan"],"tags":["python","oop"]},"unlisted":false,"nextItem":{"title":"Design Patterns You Should Unlearn in Python-Part2","permalink":"/zh/blog/design-patterns-you-should-unlearn-in-python-part2"}}')},10336:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/protected_attr-70c2b72b17e6d2780038a5c1115b505b.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},84379:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var t=s(747),i=s(74848),r=s(28453);const o={slug:"encapsulation-beyond-syntax-do-access-modifiers-still-matter",title:"Encapsulation Beyond Syntax: Do Access Modifiers Still Matter?",authors:["raceychan"],tags:["python","oop"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"What Are Access Modifiers?",id:"what-are-access-modifiers",level:2},{value:"Common Access Modifiers Across Languages",id:"common-access-modifiers-across-languages",level:3},{value:"Python&#39;s Convention-Based Approach",id:"pythons-convention-based-approach",level:3},{value:"How it works",id:"how-it-works",level:3},{value:"Public",id:"public",level:4},{value:"Protected",id:"protected",level:4},{value:"Private",id:"private",level:4},{value:"The &quot;Closed&quot; part in Open-Closed Principle",id:"the-closed-part-in-open-closed-principle",level:2},{value:"The Problem Without Access Modifiers",id:"the-problem-without-access-modifiers",level:3},{value:"The Solution With Proper Encapsulation",id:"the-solution-with-proper-encapsulation",level:3},{value:"Why Access Modifiers Become Less Popular",id:"why-access-modifiers-become-less-popular",level:2},{value:"Composition Over Inheritance",id:"composition-over-inheritance",level:3},{value:"Separation of Data and Behavior",id:"separation-of-data-and-behavior",level:3},{value:"Encapsulation beyond syntax",id:"encapsulation-beyond-syntax",level:2},{value:"Python",id:"python",level:3},{value:"Typescript",id:"typescript",level:3},{value:"Encapsulation beyond code",id:"encapsulation-beyond-code",level:2},{value:"Wrap it up",id:"wrap-it-up",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://unsplash.com/photos/JBZvYieOmCQ/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8N3x8bWVjaGFuaWNzfGVufDB8fHx8MTc1NDI0NjQ1OXww&force=true&w=1920",alt:"gears"})}),"\n",(0,i.jsx)(n.p,{children:"Access modifiers are ubiquitous across programming languages, yet they've become increasingly controversial in modern development. Through my experience with software development and technical discussions, I've observed a troubling pattern: many developers either treat access modifiers as meaningless ceremony or dismiss them entirely as outdated relics."}),"\n",(0,i.jsx)(n.p,{children:"This dismissive attitude stems from a fundamental misunderstanding of their purpose. Access modifiers aren't just syntactic decorations: they're essential tools for implementing encapsulation, one of object-oriented programming's core principles. When used properly, they significantly enhance code maintainability and enable effective team collaboration. Conversely, their absence or misuse leads to fragile, tightly coupled systems that become maintenance nightmares."}),"\n",(0,i.jsx)(n.p,{children:"Consider the typical enterprise codebase that has grown unwieldy over time. While poor encapsulation isn't the only culprit, it's often a primary factor in creating systems where simple changes ripple unpredictably throughout the application. This problem is particularly evident in Python projects, where the language's flexibility can mask structural issues until they become critical."}),"\n",(0,i.jsxs)(n.p,{children:["Rather than contributing to the abundance of tutorials on ",(0,i.jsx)(n.em,{children:"how"})," to use access modifiers, this article explores the deeper question: ",(0,i.jsx)(n.em,{children:"why"})," should we use them? We'll examine their role in creating maintainable software from multiple perspectives, from individual classes to entire system architectures."]}),"\n",(0,i.jsx)(n.h2,{id:"what-are-access-modifiers",children:"What Are Access Modifiers?"}),"\n",(0,i.jsx)(n.p,{children:"Access modifiers are those little gatekeepers in your code that decide who gets to touch what. They're language constructs that control the visibility of class members: properties, methods, inner secrets, and they\u2019re a cornerstone of something much bigger: encapsulation."}),"\n",(0,i.jsx)(n.p,{children:"Encapsulation is about drawing clean lines between what your code offers to the outside world, and what it hides for internal use only. And access modifiers? They\u2019re how we draw those lines."}),"\n",(0,i.jsx)(n.p,{children:"Think of them as your API\u2019s \u201cdo not enter\u201d signs, or lack thereof."}),"\n",(0,i.jsx)(n.h3,{id:"common-access-modifiers-across-languages",children:"Common Access Modifiers Across Languages"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Language"}),(0,i.jsx)(n.th,{children:"Public"}),(0,i.jsx)(n.th,{children:"Protected"}),(0,i.jsx)(n.th,{children:"Private"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"C++"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"public:"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"protected:"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"private:"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Python"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"name"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"_name"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"__name"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"C++:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"  class UserRepository {\n  public:\n      UserRepository(std::shared_ptr<DatabaseEngine> engine) : _engine(engine) {}\n\n      bool add_user(const UserProfile& user) {\n          _validate_email(user.email);\n          // do insert query here\n          return true;\n      }\n\n  protected:\n      std::shared_ptr<DatabaseEngine> _engine;  // Protected member (underscore prefix)\n\n      void _validate_email(const std::string& email) {  // Protected method (underscore prefix)\n          if (email.find('@') == std::string::npos) {\n              throw std::invalid_argument(\"Not a valid email\");\n          }\n      }\n  };\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Python:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from sqlalchemy.ext.asyncio import AsyncEngine\nfrom typing import Optional\nfrom .model import UserProfile\n\nclass UserRepository:\n    def __init__(self, engine: AsyncEngine):\n        self._engine = engine           # Protected\n    \n    def add_user(self, user: UserProfile) -> bool:          # Public\n        self._validate_email(user.email)\n\n        stmt = # insert user query ...\n        async with self._engine.begin() as conn:\n            await self.conn.execute(stmt)\n    \n    def _validate_email(self, email: str):\n        if not "@" in email:\n            raise ValueError("Not a valid email")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pythons-convention-based-approach",children:"Python's Convention-Based Approach"}),"\n",(0,i.jsxs)(n.p,{children:["You might notice that, there is no ",(0,i.jsx)(n.code,{children:"protected"}),", ",(0,i.jsx)(n.code,{children:"public"})," keyword like our cpp example and that's right,\nunlike C++ or Java, Python doesn\u2019t really enforce access control. It just politely asks you not to touch certain things and hopes you\u2019re mature enough to listen. This approach, known as \u201cconsenting adults\u201d, relies on naming conventions rather than hard rules."]}),"\n",(0,i.jsx)(n.p,{children:"So in Python:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"name"})," = public"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"_name"})," = protected (but really just a hint)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__name"})," = private (with name mangling)"]}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works",children:"How it works"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s walk through each level of access with proper Python examples."}),"\n",(0,i.jsx)(n.h4,{id:"public",children:"Public"}),"\n",(0,i.jsx)(n.p,{children:"Public members are the official interface of your class. Anyone can read or modify them."}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s especially true with dataclasses."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from dataclasses import dataclass\n\n@dataclass\nclass User:\n    email: str\n    is_active: bool\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["here every member of ",(0,i.jsx)(n.code,{children:"User"})," is made public"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Why? Because dataclass is built for one very specific job: representing data. The fields in a dataclass are just values(python builtin types, or other dataclasses), not resources, not services, not open sockets.  There's no side effect when you read or write to them. That simplicity makes it safe (and sensible) for those fields to be public by default."}),"\n",(0,i.jsx)(n.p,{children:"In practice, dataclasses are usually fully exposed (as value objects). The use case where you\u2019d expose some fields but guard others, the kind that might warrant access modifiers, is not what dataclasses are meant for. That kind of partial encapsulation calls for a regular class, not a dataclass."}),"\n",(0,i.jsx)(n.h4,{id:"protected",children:"Protected"}),"\n",(0,i.jsx)(n.p,{children:"Protected members are for \u201cinternal use\u201d by the class itself and its subclasses. In Python, a single underscore (_name) signals this. It\u2019s not enforced by the interpreter, but it\u2019s a strong hint: \u201cthis is not part of the public API.\u201d"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UserService:\n    def __init__(self, user_repo: UserRepository):\n        self._user_repo = user_repo\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Can another module access ",(0,i.jsx)(n.code,{children:"_user_repo"}),"? Yes. Should it? Probably not."]}),"\n",(0,i.jsxs)(n.p,{children:["Python won\u2019t slap your wrist for accessing ",(0,i.jsx)(n.code,{children:"_user_repo"}),", but if you later break your app by depending on internals you weren\u2019t supposed to touch, well, that\u2019s on you."]}),"\n",(0,i.jsx)(n.p,{children:"Wouldn't it be nice if someone warned you when you accidentally stepped over the line?"}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s where Python\u2019s type-checking ecosystem comes in. Before Python 3.6, this kind of static checking wasn\u2019t realistic. But now, with tools like pyright or mypy, you can actually get warnings when you misuse protected members."}),"\n",(0,i.jsx)(n.p,{children:"To enable this, add the following to your pyproject.toml:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[tool.pyright]\nexclude = ["tests"]\ninclude = ["lihil/*.py"]\npython_version = "3.10"\ntypeCheckingMode = "strict"\n'})}),"\n",(0,i.jsx)(n.p,{children:"If you're using an editor like VSCode, it\u2019ll now helpfully highlight any inappropriate access to protected fields: either with a squiggly underline or a firm tooltip telling you to back off."}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of how vscode would complain if you access protected attribute from outside of the class"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"protected attr",src:s(10336).A+"",width:"1907",height:"262"})}),"\n",(0,i.jsx)(n.p,{children:"It\u2019s not bulletproof, but it\u2019s enough to catch most accidental misuse, and that alone can save you a debugging session or three."}),"\n",(0,i.jsx)(n.h4,{id:"private",children:"Private"}),"\n",(0,i.jsx)(n.p,{children:"Double underscore time. When you prefix a name with __, Python uses name mangling to make it harder to access from outside the class."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class TokenManager:\n    def __init__(self):\n        self.__secret_key = "super-secret"\n\n    def validate(self, token: str) -> bool:\n        return token.endswith(self.__secret_key)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now if you try to access ",(0,i.jsx)(n.code,{children:"manager.__secret_key"}),"c, you\u2019ll get an AttributeError. Looks private, right?"]}),"\n",(0,i.jsx)(n.p,{children:"But try just a little harder:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'>>> manager._TokenManager__secret_key\n>>> "super-secret"\n'})}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s all name mangling is, nothing fancy, no real security. It\u2019s basically just renaming a key in a dictionary:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'cls_dict[attr_name] = f"_{cls.__name__}{attr_name}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"This isn\u2019t about locking things down. It\u2019s about discouraging accidents, especially the kind caused by autocomplete or careless refactors. It prevents casual misuse, not determined inspection."}),"\n",(0,i.jsx)(n.p,{children:"So yes, it\u2019s obscurity, not security, and it\u2019s doing exactly what it was designed to do."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Protected vs Private"}),"\n",(0,i.jsx)(n.p,{children:'Many people get confused by the difference between protected vs private, some would call both of them "private".'}),"\n",(0,i.jsx)(n.p,{children:"the difference is indeed subtle, it is mainly for who are you hiding from? protected hiding information from outside of the class(where subclasses are still considered insider), where as private hiding information from everyone execept the class itself."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-closed-part-in-open-closed-principle",children:'The "Closed" part in Open-Closed Principle'}),"\n",(0,i.jsx)(n.p,{children:"The Open-Closed Principle (OCP) says that software entities should be open for extension, but closed for modification. It sounds fancy, but here's the practical translation: you should be able to add new behavior without rewriting old code."}),"\n",(0,i.jsx)(n.p,{children:"That second part, closed for modification, is where access modifiers come in. It's about protecting existing code from unintentional breakage. If your module exposes all of its internals to the outside world, then any change, even a harmless-looking one, risks breaking someone else\u2019s code."}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s walk through a real-world-ish example."}),"\n",(0,i.jsx)(n.h3,{id:"the-problem-without-access-modifiers",children:"The Problem Without Access Modifiers"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose we\u2019re building a UserService that provides the read/writer of ",(0,i.jsx)(n.code,{children:"UserProfile"})," to other world."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UserRepository:\n    def add_user(self, user: UserProfile) -> None:\n        ...\n\nclass UserService:\n    def __init__(self, repo: UserRepository):\n        self.repository = repo\n\n    def register(self, email: str, name: str) -> UserProfile:\n        user = UserProfile(email=email, name=name)\n        self.repository.add_user(user)\n        return user\n"})}),"\n",(0,i.jsx)(n.p,{children:"Everything works fine... until another service comes along and decides it\u2019s faster to just skip UserService entirely:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Somewhere else in the codebase\nservice = UserService()\nuser = UserProfile(email="a@example.com", name="Alice")\nservice.repository.add_user(user)  # Uh-oh\n'})}),"\n",(0,i.jsx)(n.p,{children:"That might seem harmless, but now your internal behavior is part of someone else's dependency. You can't refactor add_user() without checking who else might be calling it. You can\u2019t change validation rules, logging, or caching logic in register() because someone has bypassed it completely."}),"\n",(0,i.jsx)(n.p,{children:"So now you're stuck. You want to improve your implementation, but you can't, because you're afraid to break downstream code that was never supposed to depend on this stuff in the first place."}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s what \u201cclosed for modification\u201d is really about: being able to change your code without changing its consumers. And that only works if you give them a stable, public interface, and hide the rest."}),"\n",(0,i.jsx)(n.h3,{id:"the-solution-with-proper-encapsulation",children:"The Solution With Proper Encapsulation"}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s rewrite that UserService example ,but this time, with some actual boundaries."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class UserRepository:\n    def add_user(self, user: UserProfile) -> None:\n        ...\n\n    def find_by_email(self, email: str) -> UserProfile | None:\n        ...\n\nclass UserService:\n    def __init__(self, repository: UserRepository):\n        self._repository = repository                # protected\n\n    def register(self, email: str, name: str) -> UserProfile:\n        user = UserProfile(email=email, name=name)\n        self._repository.add_user(user)\n        return user\n"})}),"\n",(0,i.jsx)(n.p,{children:"This version actually respects encapsulation. The UserService offers one clear, well-defined public method: register(). That\u2019s the official way to create a user, and it\u2019s the only thing external code should be calling."}),"\n",(0,i.jsxs)(n.p,{children:["Everything else, like the repository, is considered internal. It's still accessible in Python if someone really wants to go spelunking, but we've marked it as protected ",(0,i.jsx)(n.code,{children:"_repository"})," to signal our intent: this is not part of the public contract. If you reach in and touch it, you\u2019re on your own."]}),"\n",(0,i.jsx)(n.p,{children:"This pattern maintains a clean separation between what the outside world should use and what it shouldn\u2019t touch. It keeps your service focused, predictable, and safe to refactor, without the risk of breaking someone else's code just because you renamed a helper or swapped out your persistence layer."}),"\n",(0,i.jsx)(n.h2,{id:"why-access-modifiers-become-less-popular",children:"Why Access Modifiers Become Less Popular"}),"\n",(0,i.jsx)(n.p,{children:"Access modifiers continue to serve an important role in defining clear boundaries within code, but their practical usage has shifted alongside modern software design practices. As the industry has moved toward modular architectures and composition-based design, the need for strict access control has diminished in many scenarios."}),"\n",(0,i.jsx)(n.h3,{id:"composition-over-inheritance",children:"Composition Over Inheritance"}),"\n",(0,i.jsx)(n.p,{children:"Historically, access modifiers(private, specifically) were often used to safeguard internals from misuse by subclasses. But as composition has become the preferred alternative to inheritance, particularly in languages like Rust and Go, this concern has become less relevant. Go, for example, lacks inheritance entirely and does not include traditional access modifiers beyond public/private naming conventions. Yet it remains highly capable of building well-encapsulated, maintainable systems."}),"\n",(0,i.jsx)(n.h3,{id:"separation-of-data-and-behavior",children:"Separation of Data and Behavior"}),"\n",(0,i.jsx)(n.p,{children:"Another factor is the growing tendency to decouple data structures from business logic. In Python, for instance, dataclass objects are typically used to represent data without complex behavior. Since they don\u2019t carry logic that needs to be guarded, fine-grained access control becomes less critical. Instead, we rely on conventions and well-defined interfaces to guide correct usage."}),"\n",(0,i.jsx)(n.h2,{id:"encapsulation-beyond-syntax",children:"Encapsulation beyond syntax"}),"\n",(0,i.jsx)(n.p,{children:"Access modifiers are one way to draw boundaries, but they\u2019re not the only way. Many languages embrace encapsulation by convention, tooling, or structure, even if they don\u2019t have formal protected or private keywords."}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s look at a few quick examples:"}),"\n",(0,i.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# token_serivce/__init__.py\nfrom .service import TokenService\n\n__all__ = ["TokenService"]  # Everything else stays internal\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:'or just name other top level members with "_" prefix.'}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"typescript",children:"Typescript"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// token_serivce.ts\n\nexport class TokenService {}       // public\nclass InternalCache {}             // not exported = private to module\n"})}),"\n",(0,i.jsx)(n.p,{children:"These languages all use different syntactic mechanisms, but they\u2019re solving the same problem: hide what\u2019s internal, and make what\u2019s public explicit."}),"\n",(0,i.jsx)(n.p,{children:"Whether it's a leading underscore in Python, capitalization in Go, or an export keyword in TypeScript, you're doing the same thing: protecting the shape of your interface, and making your codebase safer to evolve."}),"\n",(0,i.jsx)(n.p,{children:"This is why access modifiers like protected and private are valuable, but not essential. Encapsulation is a mindset, not a keyword."}),"\n",(0,i.jsx)(n.h2,{id:"encapsulation-beyond-code",children:"Encapsulation beyond code"}),"\n",(0,i.jsxs)(n.p,{children:["Encapsulation doesn\u2019t stop at classes, functions, or modules, it applies at the ",(0,i.jsx)(n.strong,{children:"architectural level"}),", too."]}),"\n",(0,i.jsxs)(n.p,{children:["In a microservice-based system, each service is an isolated unit with its own data, logic, and internal state. You don\u2019t (and shouldn\u2019t) reach across service boundaries to query another service\u2019s database or call its internal methods. Instead, communication happens through ",(0,i.jsx)(n.strong,{children:"well-defined interfaces"}),", usually REST, gRPC, or message queues."]}),"\n",(0,i.jsx)(n.p,{children:"This is encapsulation at the system level:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A service only exposes the API endpoints it wants others to use."}),"\n",(0,i.jsx)(n.li,{children:"Internal components like DAOs, caches, feature flags, or job queues are entirely hidden."}),"\n",(0,i.jsx)(n.li,{children:"Breaking changes can be avoided because external consumers never depend on internal details."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["A good example would be an ",(0,i.jsx)(n.strong,{children:"API Gateway"}),". To the caller, it stays transparent. But behind the scenes, the gateway might route the request to multiple services, apply authentication, logging, retries, or circuit-breaking logic. None of that is exposed. The caller doesn't know, and doesn't need to."]}),"\n",(0,i.jsxs)(n.p,{children:["It\u2019s the same idea as ",(0,i.jsx)(n.code,{children:"private"})," or ",(0,i.jsx)(n.code,{children:"protected"}),", just scaled out over a network."]}),"\n",(0,i.jsx)(n.p,{children:"Whether you\u2019re defining a Python method, a Go module, or a service boundary in your infrastructure, the principle is the same:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Hide internal details. Expose a clean, intentional interface. Decouple everything else."})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"That\u2019s encapsulation, even without the keyword."}),"\n",(0,i.jsx)(n.h2,{id:"wrap-it-up",children:"Wrap it up"}),"\n",(0,i.jsxs)(n.p,{children:["We started with a question: ",(0,i.jsx)(n.strong,{children:"Do access modifiers still matter?"})," And the answer is yes, but not because of the syntax. They matter because they support a much bigger principle: ",(0,i.jsx)(n.strong,{children:"encapsulation"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Throughout this article, we\u2019ve explored how access modifiers like ",(0,i.jsx)(n.code,{children:"private"}),", ",(0,i.jsx)(n.code,{children:"protected"}),", and even Python\u2019s humble underscore help draw boundaries between what\u2019s internal and what\u2019s public. But we\u2019ve also seen that encapsulation goes far beyond these keywords. It lives in:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Class design"}),", through naming and structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Module and package organization"}),", via ",(0,i.jsx)(n.code,{children:"__all__"}),", leading underscores, and folder layout"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Language conventions"}),", like capitalization in Go or ",(0,i.jsx)(n.code,{children:"export"})," in TypeScript"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"System architecture"}),", where APIs and service boundaries define what\u2019s accessible"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So no. access modifiers aren\u2019t meaningless ceremony, and they\u2019re not relics either. They\u2019re part of a larger toolkit we use to manage complexity, reduce coupling, and protect ourselves (and our teammates) from the chaos of accidental dependencies."}),"\n",(0,i.jsxs)(n.p,{children:["Even in a language like Python, where access control is convention-driven and technically unenforced, ",(0,i.jsx)(n.strong,{children:"encapsulation still matters"}),". In fact, it might matter ",(0,i.jsx)(n.em,{children:"more"}),", because we rely on discipline, design, and clarity rather than compiler enforcement."]}),"\n",(0,i.jsx)(n.p,{children:"If there\u2019s one idea to walk away with, it\u2019s this:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Encapsulation isn\u2019t about what the language allows, it\u2019s about what the design intends."})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Use access modifiers when they help. Use structure, convention, and documentation when they don\u2019t. Just make sure your interfaces are clear, your boundaries are meaningful, and your internals stay safely tucked away where they belong."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);
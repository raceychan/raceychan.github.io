"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[1079],{423:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"http/request/body","title":"body","description":"While path, query, and header parameters are usually small bits of data encoded in the URL or headers, body parameters carry the main payload of a request. They\'re typically used in methods like POST, PUT, and PATCH, where a client needs to send structured data to the server.","source":"@site/docs/http/request/body.md","sourceDirName":"http/request","slug":"/http/request/body-parameter","permalink":"/docs/http/request/body-parameter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"body","slug":"body-parameter"},"sidebar":"tutorialSidebar","previous":{"title":"cookie","permalink":"/docs/http/request/cookie-parameter"},"next":{"title":"form","permalink":"/docs/http/request/from-data"}}');var n=r(4848),s=r(8453);const o={sidebar_position:4,title:"body",slug:"body-parameter"},i="Body Parameters",d={},l=[{value:"Constraints and Validation",id:"constraints-and-validation",level:2},{value:"Custom Decoders",id:"custom-decoders",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"body-parameters",children:"Body Parameters"})}),"\n",(0,n.jsx)(t.p,{children:"While path, query, and header parameters are usually small bits of data encoded in the URL or headers, body parameters carry the main payload of a request. They're typically used in methods like POST, PUT, and PATCH, where a client needs to send structured data to the server."}),"\n",(0,n.jsx)(t.p,{children:"For example:"}),"\n",(0,n.jsx)(t.p,{children:"This is a typical HTTP request with a JSON body:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-http",children:'POST /users HTTP/1.1\nContent-Type: application/json\n\n{\n  "username": "alice",\n  "age": 30\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"Declaring Body Parameters in lihil\nIn lihil, there are two ways to declare request bodies:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Implicitly with msgspec.Struct\nYou can simply define a body model using msgspec.Struct, and lihil will automatically treat it as the request body:"}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'\nimport msgspec\nfrom lihil import Route\n\nclass CreateUser(msgspec.Struct):\n    username: str\n    age: int\n\nuser = Route("/users")\n\n@user.post\nasync def create_user(data: CreateUser) -> str:\n    return f"Hello {data.username}!"\n'})}),"\n",(0,n.jsx)(t.p,{children:"This is the preferred way when your request body is a structured object (e.g., a JSON document)."}),"\n",(0,n.jsxs)(t.ol,{start:"2",children:["\n",(0,n.jsx)(t.li,{children:'Explicitly with Param("body")'}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'If you want to be explicit, or if you are combining body data with other types of parameters, you can use Param("body"):'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from lihil import Param\nfrom typing import Annotated\n\n@user.post\nasync def create_user(\n    data: Annotated[CreateUser, Param("body")]\n) -> str:\n    return f"Hello {data.username}!"\n'})}),"\n",(0,n.jsx)(t.p,{children:"This approach is espceially useful when your body is a primitive value like a string or a list."}),"\n",(0,n.jsx)(t.h2,{id:"constraints-and-validation",children:"Constraints and Validation"}),"\n",(0,n.jsx)(t.p,{children:"Since body parameters use msgspec, you can apply validation constraints directly in your Struct, or via Param, just like you would with path or query parameters:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"from lihil import Param\nfrom typing import Annotated\n\nclass CreateUser(msgspec.Struct):\n    username: Annotated[str, Param(min_length=3, max_length=30)]\n    age: Annotated[int, Param(ge=0, le=120)]\n"})}),"\n",(0,n.jsx)(t.h2,{id:"custom-decoders",children:"Custom Decoders"}),"\n",(0,n.jsx)(t.p,{children:"For advanced use cases, you can supply a custom decoder via Param:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from lihil import Param\nfrom typing import Annotated\n\ndef parse_data(value: bytes) -> CreateUser:\n    # your custom logic\n    return CreateUser(...)\n\n@user.post\nasync def create_user(\n    data: Annotated[CreateUser, Param("body", decoder=parse_data)]\n): ...\n'})}),"\n",(0,n.jsx)(t.p,{children:"This gives you full control over how raw body bytes are interpreted."}),"\n",(0,n.jsxs)(t.p,{children:["In summary, body parameters are a powerful way to send structured data in HTTP requests. They are essential for APIs that need to accept complex data types, such as JSON objects or binary files. Lihil makes it easy to work with body parameters, allowing you to define them using ",(0,n.jsx)(t.code,{children:"msgspec.Struct"})," or ",(0,n.jsx)(t.code,{children:'Param("body")'}),". You can also apply validation constraints and even use custom decoders for advanced scenarios."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>i});var a=r(6540);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[7450],{22346:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"advance/plugin/plugin","title":"Plugin System","description":"lihil provides a flexible plugin system that allows you to decorate endpoint functions with custom logic \u2014 without interfering with parameter parsing or signature analysis.","source":"@site/docs/advance/plugin/plugin.md","sourceDirName":"advance/plugin","slug":"/advance/plugin/","permalink":"/docs/advance/plugin/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"middleware","permalink":"/docs/http/middleware"},"next":{"title":"jwt","permalink":"/docs/advance/plugin/jwt"}}');var t=i(74848),a=i(28453);const s={},l="Plugin System",o={},p=[{value:"Why makes it good?",id:"why-makes-it-good",level:2},{value:"IPlugin Interface",id:"iplugin-interface",level:2},{value:"Registering Plugins",id:"registering-plugins",level:2},{value:"plugin factory",id:"plugin-factory",level:3},{value:"Writing a Plugin",id:"writing-a-plugin",level:2},{value:"Plugin Parameters",id:"plugin-parameters",level:2},{value:"EndpointSignature",id:"endpointsignature",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"plugin-system",children:"Plugin System"})}),"\n",(0,t.jsx)(e.p,{children:"lihil provides a flexible plugin system that allows you to decorate endpoint functions with custom logic \u2014 without interfering with parameter parsing or signature analysis."}),"\n",(0,t.jsx)(e.p,{children:"This is particularly useful for features like logging, metrics, authentication, or request tracing."}),"\n",(0,t.jsx)(e.h2,{id:"why-makes-it-good",children:"Why makes it good?"}),"\n",(0,t.jsx)(e.p,{children:"In similar ASGI frameworks, it is difficult to build composable, third-party plugins due to several limitations:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Signature enforcement: You can't simply add a custom dependency to the endpoint signature \u2014 The framework will try to parse and validate it, potentially raising errors."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Decorator restrictions: You can't freely decorate the endpoint function \u2014 the decorator must strictly preserve the function's signature or it will break."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Lack of introspection: Decorators don't know what the endpoint function looks like, which makes it hard to write reusable, signature-aware plugins."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"lihil avoids these limitations by introducing a plugin system that operates after the application has initialized, giving full access to dependency graphs and endpoint metadata."}),"\n",(0,t.jsx)(e.h2,{id:"iplugin-interface",children:"IPlugin Interface"}),"\n",(0,t.jsx)(e.p,{children:"A plugin in lihil is a callable (sync or async) that receives:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["the ",(0,t.jsx)(e.code,{children:"ididi.Graph"})," (dependency graph) owned by the application, containing all the registered dependencies and their configurations."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"the raw endpoint function,"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"the fully parsed EndpointSignature."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This happens after the lifespan event, ensuring that plugins can rely on resources created during lifespan handler."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from typing import Any, Awaitable, Callable, Protocol\nfrom ididi import Graph\nfrom lihil.interface import IAsyncFunc, P, R\nfrom lihil.signature import EndpointSignature\n\n\nclass IAsyncPlugin(Protocol, Generic[P, R]):\n    async def __call__(\n        self,\n        graph: Graph,\n        func: IAsyncFunc[P, R],\n        sig: EndpointSignature[Any],\n        /,\n    ) -> IAsyncFunc[P, R]: ...\n\n\nclass ISyncPlugin(Protocol, Generic[P,R]):\n    def __call__(\n        self,\n        graph: Graph,\n        func: IAsyncFunc[P, R],\n        sig: EndpointSignature[Any],\n        /,\n    ) -> IAsyncFunc[P, R]: ...\n\n\nIPlugin = IAsyncPlugin[..., Any] | ISyncPlugin[..., Any]\n"})}),"\n",(0,t.jsx)(e.h2,{id:"registering-plugins",children:"Registering Plugins"}),"\n",(0,t.jsx)(e.p,{children:"You can apply plugins at two levels:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Per-Route Plugins"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"\nfrom lihil import Route\nfrom lihil.routing import EndpointProps\n\n\nroute = Route(props=EndpointProps(plugins=[MyPlugin()]))\n"})}),"\n",(0,t.jsxs)(e.p,{children:["All endpoints registered under this route will automatically use ",(0,t.jsx)(e.code,{children:"MyPlugin"}),"."]}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:"Per-Endpoint Plugins"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"\n   @route.get(plugins=[MyPlugin()])\n   async def my_endpoint() -> None:\n   ...\n"})}),"\n",(0,t.jsx)(e.p,{children:"This allows fine-grained control for applying plugins only to specific endpoints."}),"\n",(0,t.jsx)(e.h3,{id:"plugin-factory",children:"plugin factory"}),"\n",(0,t.jsxs)(e.p,{children:["Do note that plugins are called after lifespan event, instead of instantiating the plugins at import time like we did with ",(0,t.jsx)(e.code,{children:"route.get(plugins=[MyPlugin()])"}),".\nYou can wrap the plugin in a factory."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from lihil.config import lhl_get_config\n\ndef my_plugin_factory(graph: Graph, func: Callable[P, R], sig: EndpointSignature[R]): # can be either sync or async\n    config = lhl_get_config()\n    engine = Graph.resolve(Engine, url=config.db.URL)\n    return MyPlugin(engine=engine, max_conns=config.db.MAX_CONNS)\n\n@route.get(plugins=[my_plugin_factory])\nasync def my_endpoint() -> None:\n    ...\n"})}),"\n",(0,t.jsx)(e.h2,{id:"writing-a-plugin",children:"Writing a Plugin"}),"\n",(0,t.jsx)(e.p,{children:"Here's an example plugin that injects an EventBus instance into the endpoint:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"from functools import wraps\nfrom lihil.signature import EndpointSignature\nfrom ididi import Graph\nfrom typing import Callable, Awaitable\n\ndef bus_plugin(busterm: BusTerminal[Any]):\n    def inner(self, graph: Graph, func: Callable[..., Awaitable[Any]], sig: EndpointSignature[Any]):\n        for name, param in sig.plugins.items():\n            param_type = ty_get_origin(param_type) or param_type\n            if param_type is EventBus:\n                @wraps(func)\n                async def wrapped(*args, **kwargs):\n                    kwargs[name] = busterm.create_event_bus(graph)\n                    return await func(*args, **kwargs)\n                return wrapped\n        return func\n    return inner\n"})}),"\n",(0,t.jsxs)(e.p,{children:["This plugin inspects the EndpointSignature, if it finds a parameter of type ",(0,t.jsx)(e.code,{children:"EventBus"}),", it wraps the endpoint function to inject an instance of ",(0,t.jsx)(e.code,{children:"EventBus"})," created by the ",(0,t.jsx)(e.code,{children:"BusTerminal"}),"."]}),"\n",(0,t.jsxs)(e.p,{children:["If there is no any parameter of type ",(0,t.jsx)(e.code,{children:"EventBus"}),", it simply returns the original function."]}),"\n",(0,t.jsx)(e.h2,{id:"plugin-parameters",children:"Plugin Parameters"}),"\n",(0,t.jsxs)(e.p,{children:["To avoid misinterpreting your plugin-specific values (e.g., internal helpers, service locators) as HTTP request data, annotate them using ",(0,t.jsx)(e.code,{children:'Param("plugin")'}),"."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from lihil import Route\nfrom lihil.plugins.bus import bus_pluin, BusTerminal\n\nbus_term = BusTerminal()\n\n@Route("/users/{user_id}", plugsins=[bus_plugin(busterm)])\nasync def create_user(\n    user_id: str, bus: EventBus = Annotated[EventBus, Param("plugin")]\n) -> None:\n'})}),"\n",(0,t.jsxs)(e.p,{children:["This tells lihil to treat ",(0,t.jsx)(e.code,{children:"bus"})," as a plugin-managed dependency rather than a request-bound parameter."]}),"\n",(0,t.jsx)(e.h2,{id:"endpointsignature",children:"EndpointSignature"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class EndpointSignature(Base, Generic[R]):\n    route_path: str\n\n    query_params: ParamMap[QueryParam[Any]]\n    path_params: ParamMap[PathParam[Any]]\n    header_params: ParamMap[HeaderParam[Any] | CookieParam[Any]]\n    body_param: tuple[str, BodyParam[bytes | FormData, Struct]] | None\n\n    dependencies: ParamMap[DependentNode]\n    transitive_params: set[str]\n    """\n    Transitive params are parameters required by dependencies, but not directly required by the endpoint function.\n    """\n    plugins: ParamMap[PluginParam]\n\n    scoped: bool\n    form_meta: FormMeta | None\n\n    return_params: dict[int, EndpointReturn[R]]\n\n    @property\n    def default_return(self):\n        return next(iter(self.return_params.values()))\n\n    @property\n    def status_code(self):\n        return self.default_return.status\n\n    @property\n    def encoder(self):\n        return self.default_return.encoder\n\n    @property\n    def static(self) -> bool:\n        return not any(\n            (\n                self.path_params,\n                self.query_params,\n                self.header_params,\n                self.body_param,\n                self.dependencies,\n                self.plugins,\n            )\n        )\n\n    @property\n    def media_type(self) -> str:\n        default = "application/json"\n        first_return = next(iter(self.return_params.values()))\n        return first_return.content_type or default\n'})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Plugins in lihil are decorators that modify endpoint behavior at runtime. They receive full context: function, signature, and dependency graph."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Plugin parameters are explicitly marked to avoid conflict with HTTP request parsing."}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var r=i(96540);const t={},a=r.createContext(t);function s(n){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);
"use strict";(self.webpackChunkblogs=self.webpackChunkblogs||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"what-to-do-when-http-status-codes-dont-fit-your-business-error","metadata":{"permalink":"/blog/what-to-do-when-http-status-codes-dont-fit-your-business-error","source":"@site/blog/2025-04-27-http_code/content.md","title":"What to Do When HTTP Status Codes Don\u2019t Fit Your Business Error","description":"Question:","date":"2025-04-27T00:00:00.000Z","tags":[{"inline":false,"label":"WebDevelopment","permalink":"/blog/tags/WebDevelopment","description":"Best practices of webdevlopment"}],"readingTime":16.105,"hasTruncateMarker":true,"authors":[{"name":"raceychan","title":"author of lihil, a developer.","url":"https://github.com/raceychan","page":{"permalink":"/blog/authors/raceychan"},"socials":{"x":"https://x.com/raceychan","github":"https://github.com/raceychan"},"imageURL":"https://github.com/raceychan.png","key":"raceychan"}],"frontMatter":{"slug":"what-to-do-when-http-status-codes-dont-fit-your-business-error","title":"What to Do When HTTP Status Codes Don\u2019t Fit Your Business Error","authors":["raceychan"],"tags":["WebDevelopment"],"toc_min_heading_level":2,"toc_max_heading_level":5},"unlisted":false},"content":"### Question:\\n\\n**How would you choose a status code for an order that could not be processed because the customer\'s shipping address is outside the delivery zone?**\\n\\n\x3c!-- truncate --\x3e\\n\\nHTTP status codes have long been a cornerstone of web application error handling. Defined in RFC 7231, these codes serve as a standardized way for servers to communicate the outcome of a request to the client. The standard defines several categories of status codes, such as `2xx` for success, `4xx` for client errors, and `5xx` for server errors.\\n\\nQuote from [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-8.2.2):\\n\\n> HTTP clients are not required to\\n   understand the meaning of all registered status codes, though such\\n   understanding is obviously desirable.  However, a client MUST\\n   understand the class of any status code, as indicated by the first\\n   digit, and treat an unrecognized status code as being equivalent to\\n   the x00 status code of that class\\n\\nIt has become an industrial consensus to check these status codes as a way to quickly determine whether a request was successful or failed. For example, many libraries and frameworks will raise an exception if a request results in an error status. Here\'s a simple example using Python\'s `requests` library:\\n\\n```python\\nimport requests\\n\\nresponse = requests.get(\\"https://api.example.com/data\\")\\nresponse.raise_for_status() # this would raise exception when status code > 400\\nprint(\\"Data retrieved successfully!\\")\\n```\\n\\n> In this example, `raise_for_status()` automatically raises an `HTTPError` if the server returns a 4xx or 5xx status code. This is a common pattern in many applications to ensure that only successful requests are processed further.\\n\\nFor business logic errors, it\'s common to use `4xx` codes like `400 Bad Request` or `403 Forbidden` when something goes wrong. For example, a \\"premium\\" user trying to access a feature available only to \\"pro\\" users might return a `403 Forbidden` status. In such cases, the error is clear, and the status code maps well to the scenario.\\n\\nBut as web applications grow in complexity and deal with more nuanced business rules, things get trickier. Consider a scenario where **an order could not be processed because of a mismatch between the customer\'s shipping address and the delivery zone**. How should this issue be represented in terms of HTTP status codes?\\n\\nThere isn\'t an easy or clear answer. While we could use `400 Bad Request`, it doesn\'t quite capture the specific business rule violation that\'s occurring. Similarly, a `409 Conflict` could work in some cases, but it still doesn\u2019t feel precise enough. As the number of potential issues grows\u2014whether they\u2019re related to payment failures, address mismatches, or resource conflicts\u2014the more apparent it becomes that HTTP status codes are not built to handle the full complexity of modern business logic.\\n\\n\\n### What Do People Do?\\n\\nCurrently, there are a few ways the industry deals with the problem of handling business logic errors in web applications. These solutions often involve workarounds or generalizations due to the limitations of HTTP status codes. Here are some of the common approaches:\\n\\n#### Bad\\n\\n1. **Embedding Custom Status Inside Request Body**  \\n\\nOne approach is to always return a `200 OK` status code, even when the request fails, and include a custom status code in the response body. This method involves returning a business-specific error code along with additional details. \\n\\n   **Example**:\\n```json\\n   {\\n       \\"business_code\\": \\"CUSTOMIZED_BUSINESS_ERROR\\",\\n       \\"detail\\": \\"The shipping address is outside the serviceable delivery zone.\\"\\n   }\\n```\\n\\n   I have personally encountered this solution from my work a several times during my career. when the system contains only a few components, and with detailed documentation, it could work, but as the system grows and additional components (like proxies, API gateways, and logging systems) are added, this keeps creating new problems you wouldn\'t have to solve otherwise.\\n\\n2.  self-define 3-digits status code, for example, 6xx means some business rules, 700 means others, etc. \\n\\nSome solutions attempt to define their own set of status codes beyond the standard `2xx`, `4xx`, and `5xx` categories. For example, `6xx` might represent business rules, with specific codes for each scenario (e.g., `700` for some other business logic).\\n\\n\\n   **Example**: \\n```python\\n600: CONNECTION ERROR - This indicates a general connection error\\n601: INCOMPLETE ERROR - This indicates sever sends an incomplete page/object (as indicated by Content-Length header)\\n701: ERROR TEXT FOUND - This code is returned if any error text (such as, \\"Service Unavailable\\") are found in the main page (frame HTML contents included). Note that the error text must be defined in advance of the test. Error text means if the text is found, this session should be considered a failure.\\n```\\n\\n While this avoids reading the request body to determine failure, it violates the HTTP standards, meaning many tools might throw errors or not support these codes.\\nAccording to [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-8.2.2)\\n\\n>New status codes are required to fall under one of the categories\\n   defined in [Section 6](https://datatracker.ietf.org/doc/html/rfc7231#section-6).\\n\\nstatus codes >= 600 are invalid because they fall outside of the defined categories.\\n\\n#### OK\\n\\n1. **A 4xx status code + Generic Error Message**  \\nA common fallback is to return a `4xx` status code (typically `400 Bad Request`) and include a generic error message such as \\"Something went wrong\\" in the response body. \\n```json\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Something went wrong\\"\\n}\\n```\\n\\n\\nThis approach hides the real cause of the business logic failure and lumps all client errors into one vague category. While this might suffice for small-scale applications or early prototypes, it quickly becomes inadequate as the complexity of business rules increases.\\n\\nSome systems go a step further by returning a one-line reason phrase or a slightly extended message, but still fall short of conveying structured, actionable error details to clients.\\n\\n\\n2. **Using the Same Status Code for Multiple Business Logic Issues**  \\n\\n```json\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Payment failed\\"\\n}\\n\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Invalid shipping address\\"\\n}\\n```\\n\\nAs business logic errors grow in number and variety, some teams attempt to fit them into a limited set of existing status codes. For instance, both a payment failure due to insufficient funds and a mismatch in shipping address might be returned as `400 Bad Request`. While this approach simplifies server-side handling, it severely limits the clarity of error messages, making it hard for clients to distinguish between different types of business failures. This also places unnecessary burden on client-side developers to reverse-engineer the true nature of the error from vague responses.\\n\\n\\n#### Good \\n\\n**Structured Error Message + Documentation (With Standards Compliance)**  \\n\\nA thoughtful approach to business rule violations is to return an appropriate `4xx` status code\u2014ideally one that aligns semantically with the error (for example, `407 Proxy Authentication Required`, if applicable)\u2014to indicate that the request was unsuccessful due to a business constraint.\\n\\nIn addition, the response body can include a **structured error message** based on [RFC 9457 (Problem Details for HTTP APIs)](https://datatracker.ietf.org/doc/html/rfc9457), which defines fields such as `type`, `title`, `status`, `detail`, and `instance`. This format encourages clarity and consistency, making it easier for both developers and automated systems to understand, handle, and trace errors.\\n\\nEqually important is having each error type **clearly documented** so that client developers know what an error means and how to address it. Well-maintained documentation enables richer client experiences, reduces guesswork, and helps prevent issues before they arise.\\n\\nStripe does an excellent job in this area with their [dedicated error code documentation](https://docs.stripe.com/error-codes), which provides detailed explanations for a wide range of business-related errors. Their commitment to transparency and developer experience is evident and commendable.\\n\\nThat said, there are a couple of areas where further improvements could enhance the experience even more:\\n\\n- Their structured error format, while clear, doesn\u2019t explicitly follow RFC 9457, and omits fields like `instance` that can be valuable for debugging.\\n- It\u2019s not clear whether their documentation is automatically generated or manually maintained. If it\u2019s the latter, this could introduce challenges in keeping it fully up to date with evolving APIs.\\n\\nStill, Stripe\'s approach represents a strong foundation. By building on this with standards-based structures and automation, error handling can become even more predictable, maintainable, and user-friendly.\\n\\n### How lihil solves this problem\\n\\n\\n**Structured Error Messages + Auto-Generated Documentation**\\n\\n`lihil` tackles the problem by making structured error handling first-class. You can declare rich, type-safe exceptions by subclassing `HTTPException[T]`, where `T` defines the structure of the error\'s `detail` field. These exceptions can then be directly attached to endpoints using the `errors=` parameter. This not only ensures consistent error responses but also enables `lihil` to automatically generate OpenAPI documentation for each declared error\u2014including a link to a detailed problem page under the \\"External documentation\\" tab.\\n\\nEvery error response follows the [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457) format, including fields like `type`, `title`, `status`, `detail`, and `instance`. You can customize how errors are rendered by registering handlers with `@problem_solver`, which maps specific exceptions or status codes to structured responses. Specific exception handlers take precedence over status-code-based ones, giving you fine-grained control.\\n\\nBy default, `lihil` also generates detailed responses for common issues such as missing parameters, returning structured 422 responses for `InvalidRequestErrors`\u2014complete with field-level information. These responses are not only machine-readable but also fully documented out of the box.\\n\\nBest of all, all this documentation is automatically synced with your code. There\'s no need to manually update or maintain a separate error code reference. `lihil` keeps your API behavior and documentation in perfect alignment.\\n\\n```python\\nfrom lihil import Empty, Lihil, Resp, Route, status, Meta\\nfrom lihil.interface import Base\\nfrom lihil.problems import HTTPException\\n\\nclass AddressOutOfScopeProblem(Base):\\n    current_address: Annotated[str, Meta(examples=[\\"home\\"])]\\n    service_radius: Annotated[float, Meta(examples=[3.5])]\\n    distance: Annotated[float, Meta(examples=4)]\\n\\n    message: str = \\"\\"\\n\\n    def __post_init__(self):\\n        self.message = f\\"Your current address {self.current_address} is {self.distance} miles away and our service radius is {self.service_radius}\\"\\n\\nclass InvalidOrderError(HTTPException[AddressOutOfScopeProblem]):\\n    \\"Address out of service zone\\"\\n    __status__ = 422\\n\\n    instance: Annotated[str, Meta(examples=[\\"2cd20e0c-9ddc-4fdc-8f61-b32f62ac784d\\"])]\\n    detail: AddressOutOfScopeProblem\\n\\n\\norders = Route(\\"orders\\")\\n\\n@orders.post(errors=[InvalidOrderError])\\nasync def create_orders() -> Resp[Empty, status.CREATED]: ...\\n\\nlhl = Lihil(routes=[orders])\\n\\nif __name__ == \\"__main__\\":\\n    lhl.run(__file__)\\n```The problem\\n\\n**Finite number of status code vs infinite numer of  business errors**\\n\\n\x3c!-- truncate --\x3e\\n\\nHTTP status codes have long been a cornerstone of web application error handling. Defined in RFC 7231, these codes serve as a standardized way for servers to communicate the outcome of a request to the client. The standard defines several categories of status codes, such as `2xx` for success, `4xx` for client errors, and `5xx` for server errors.\\n\\nQuote from [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-8.2.2):\\n\\n> HTTP clients are not required to\\n   understand the meaning of all registered status codes, though such\\n   understanding is obviously desirable.  However, a client MUST\\n   understand the class of any status code, as indicated by the first\\n   digit, and treat an unrecognized status code as being equivalent to\\n   the x00 status code of that class\\n\\nIt has become an industrial consensus to check these status codes as a way to quickly determine whether a request was successful or failed. For example, many libraries and frameworks will raise an exception if a request results in an error status. Here\'s a simple example using Python\'s `requests` library:\\n\\n```python\\nimport requests\\n\\nresponse = requests.get(\\"https://api.example.com/data\\")\\nresponse.raise_for_status() # this would raise exception when status code > 400\\nprint(\\"Data retrieved successfully!\\")\\n```\\n\\n> In this example, `raise_for_status()` automatically raises an `HTTPError` if the server returns a 4xx or 5xx status code. This is a common pattern in many applications to ensure that only successful requests are processed further.\\n\\nFor business logic errors, it\'s common to use `4xx` codes like `400 Bad Request` or `403 Forbidden` when something goes wrong. For example, a \\"premium\\" user trying to access a feature available only to \\"pro\\" users might return a `403 Forbidden` status. In such cases, the error is clear, and the status code maps well to the scenario.\\n\\nBut as web applications grow in complexity and deal with more nuanced business rules, things get trickier. Consider a scenario where **an order could not be processed because of the customer\'s shipping address is out of the delivery zone**. How should this issue be represented in terms of HTTP status codes?\\n\\nThere isn\'t an easy or clear answer. While we could use `400 Bad Request`, it doesn\'t quite capture the specific business rule violation that\'s occurring. Similarly, a `409 Conflict` could work in some cases, but it still doesn\u2019t feel precise enough. As the number of potential issues grows\u2014whether they\u2019re related to payment failures, address mismatches, or resource conflicts\u2014the more apparent it becomes that HTTP status codes are not built to handle the full complexity of modern business logic.\\n\\n\\n### What Do People Do?\\n\\nCurrently, there are a few ways the industry deals with the problem of handling business logic errors in web applications. These solutions often involve workarounds or generalizations due to the limitations of HTTP status codes. Here are some of the common approaches:\\n\\n#### Bad\\n\\n1. **Embedding Custom Status Inside Request Body**  \\n\\nOne approach is to always return a `200 OK` status code, even when the request fails, and include a custom status code in the response body. This method involves returning a business-specific error code along with additional details. \\n\\n   **Example**:\\n```json\\n   {\\n       \\"business_code\\": \\"CUSTOMIZED_BUSINESS_ERROR\\",\\n       \\"detail\\": \\"The shipping address is outside the serviceable delivery zone.\\"\\n   }\\n```\\n\\n   I have personally encountered this solution from my work a several times during my career. when the system contains only a few components, and with detailed documentation, it could work, but as the system grows and additional components (like proxies, API gateways, and logging systems) are added, this keeps creating new problems you wouldn\'t have to solve otherwise.\\n\\n2.  self-define 3-digits status code, for example, 6xx means some business rules, 700 means others, etc. \\n\\nSome solutions attempt to define their own set of status codes beyond the standard `2xx`, `4xx`, and `5xx` categories. For example, `6xx` might represent business rules, with specific codes for each scenario (e.g., `700` for some other business logic). While this avoids reading the request body to determine failure, it violates the HTTP standards, meaning many tools might throw errors or not support these codes.\\n   **Example**: \\n```python\\n600: CONNECTION ERROR - This indicates a general connection error\\n601: INCOMPLETE ERROR - This indicates sever sends an incomplete page/object (as indicated by Content-Length header)\\n701: ERROR TEXT FOUND - This code is returned if any error text (such as, \\"Service Unavailable\\") are found in the main page (frame HTML contents included). Note that the error text must be defined in advance of the test. Error text means if the text is found, this session should be considered a failure.\\n```\\n\\n\\nAccording to [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231#section-8.2.2), \\n> New status codes are required to fall under one of the categories\\n   defined in [Section 6](https://datatracker.ietf.org/doc/html/rfc7231#section-6).\\n\\nstatus codes >= 600 are invalid because they fall outside of the defined categories.\\n\\n\\n#### OK\\n\\n1. **A 4xx status code + Generic Error Message**  \\n\\n```json\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Something went wrong\\"\\n}\\n```\\n\\nA common fallback is to return a `4xx` status code (typically `400 Bad Request`) and include a generic error message such as \\"Something went wrong\\" in the response body. This approach hides the real cause of the business logic failure and lumps all client errors into one vague category. While this might suffice for small-scale applications or early prototypes, it quickly becomes inadequate as the complexity of business rules increases.\\n\\nSome systems go a step further by returning a one-line reason phrase or a slightly extended message, but still fall short of conveying structured, actionable error details to clients.\\n\\n2. **Using the Same Status Code for Multiple Business Logic Issues**  \\n\\n```json\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Payment failed\\"\\n}\\n\\n{\\n  \\"status\\": 400,\\n  \\"message\\": \\"Invalid shipping address\\"\\n}\\n```\\n\\nAs business logic errors grow in number and variety, some teams attempt to fit them into a limited set of existing status codes. For instance, both a payment failure due to insufficient funds and a mismatch in shipping address might be returned as `400 Bad Request`. While this approach simplifies server-side handling, it severely limits the clarity of error messages, making it hard for clients to distinguish between different types of business failures. This also places unnecessary burden on client-side developers to reverse-engineer the true nature of the error from vague responses.\\n\\n\\n#### Good \\n\\n**Structured Error Message + Documentation (With Standards Compliance)**  \\n\\nA thoughtful approach to business rule violations is to return an appropriate `4xx` status code\u2014ideally one that aligns semantically with the error (for example, `407 Proxy Authentication Required`, if applicable)\u2014to indicate that the request was unsuccessful due to a business constraint.\\n\\nIn addition, the response body can include a **structured error message** based on [RFC 9457 (Problem Details for HTTP APIs)](https://datatracker.ietf.org/doc/html/rfc9457), which defines fields such as `type`, `title`, `status`, `detail`, and `instance`. This format encourages clarity and consistency, making it easier for both developers and automated systems to understand, handle, and trace errors.\\n\\nEqually important is having each error type **clearly documented** so that client developers know what an error means and how to address it. Well-maintained documentation enables richer client experiences, reduces guesswork, and helps prevent issues before they arise.\\n\\nStripe does an excellent job in this area with their [dedicated error code documentation](https://docs.stripe.com/error-codes), which provides detailed explanations for a wide range of business-related errors. Their commitment to transparency and developer experience is evident and commendable.\\n\\nThat said, there are a couple of areas where further improvements could enhance the experience even more:\\n\\n- Their structured error format, while clear, doesn\u2019t explicitly follow RFC 9457, and omits fields like `instance` that can be valuable for debugging.\\n    \\n- It\u2019s not clear whether their documentation is automatically generated or manually maintained. If it\u2019s the latter, this could introduce challenges in keeping it fully up to date with evolving APIs.\\n\\n### How lihil solves this problem\\n\\n**Structured Error Messages + Auto-Generated Documentation**\\n\\n`lihil` tackles the problem by making structured error handling first-class. You can declare rich, type-safe exceptions by subclassing `HTTPException[T]`, where `T` defines the structure of the error\'s `detail` field. These exceptions can then be directly attached to endpoints using the `errors=` parameter. This not only ensures consistent error responses but also enables `lihil` to automatically generate OpenAPI documentation for each declared error\u2014including a link to a detailed problem page under the \\"External documentation\\" tab.\\n\\nEvery error response follows the [RFC 9457](https://datatracker.ietf.org/doc/html/rfc9457) format, including fields like `type`, `title`, `status`, `detail`, and `instance`. You can customize how errors are rendered by registering handlers with `@problem_solver`, which maps specific exceptions or status codes to structured responses. Specific exception handlers take precedence over status-code-based ones, giving you fine-grained control.\\n\\nBy default, `lihil` also generates detailed responses for common issues such as missing parameters, returning structured 422 responses for `InvalidRequestErrors`\u2014complete with field-level information. These responses are not only machine-readable but also fully documented out of the box.\\n\\nBest of all, all this documentation is automatically synced with your code. There\'s no need to manually update or maintain a separate error code reference. `lihil` keeps your API behavior and documentation in perfect alignment.\\n\\n```python\\nfrom lihil import Empty, Lihil, Resp, Route, status, Meta\\nfrom lihil.interface import Base\\nfrom lihil.problems import HTTPException\\n\\nclass AddressOutOfScopeProblem(Base):\\n    current_address: Annotated[str, Meta(examples=[\\"home\\"])]\\n    service_radius: Annotated[float, Meta(examples=[3.5])]\\n    distance: Annotated[float, Meta(examples=4)]\\n\\n    message: str = \\"\\"\\n\\n    def __post_init__(self):\\n        self.message = f\\"Your current address {self.current_address} is {self.distance} miles away and our service radius is {self.service_radius}\\"\\n\\nclass InvalidOrderError(HTTPException[AddressOutOfScopeProblem]):\\n    \\"Address out of service zone\\"\\n    __status__ = 422\\n\\n    instance: Annotated[str, Meta(examples=[\\"2cd20e0c-9ddc-4fdc-8f61-b32f62ac784d\\"])]\\n    detail: AddressOutOfScopeProblem\\n\\n\\norders = Route(\\"orders\\")\\n\\n@orders.post(errors=[InvalidOrderError])\\nasync def create_orders() -> Resp[Empty, status.CREATED]: ...\\n\\nlhl = Lihil(routes=[orders])\\n\\nif __name__ == \\"__main__\\":\\n    lhl.run(__file__)\\n```\\n\\n\\nYou would be able to the example response on OpenAPI at \\"/docs\\", asd well as the dedicated problem page at \\"/problems\\"\\n\\n![Order error diagram](./order_error.png)"}]}}')}}]);